UNUSED CASE 4 FROM GJKDIST

Not all cases are implemented, mainly to do with the tetrahedron being very flat, such as in the GJKFuncs.nb where it wrongly returns side AB

case 4:
			{
				{
					Vector3 da = mA - mD;
					Vector3 db = mB - mD;
					Vector3 dc = mC - mD;
					Vector3 ab = mB - mA;
					Vector3 bc = mC - mB;
					Vector3 ac = mC - mA;
					Vector3 nDAB = GetNormalForFace(da, db, -dc);
					Vector3 nDBC = GetNormalForFace(db, dc, -da);
					Vector3 nDCA = GetNormalForFace(dc, da, -db);
					Vector3 nABC = GetNormalForFace(ab, ac, da);
					
					if (Vector3::Dot(mD, nDAB) < 0.f)					//outside DAB
					{
						if (CoolDot(da, nDAB, -db, mD) <= 0.f)			//outside DA side on DAB
						{
							if (CoolDot(dc, nDCA, ac, mD) <= 0.f)		//outside DC side on DCA
							{
								if (CoolDot(dc, nDBC, -db, mD) <= 0.f)	//outside DC side on DBC, in voronoi region for DC
									goto REMOVE_A_AND_FINISH;//TODO

								//inside DC side on DBC
								goto REMOVE_A_AND_FINISH;
							}


							if (CoolDot(da, nDCA, -dc, mD) <= 0.f)		//outside DA side on DCA, in voronoi region for DA
								goto REMOVE_B_AND_FINISH;//TODO

							//inside DA side on DCA
							goto REMOVE_B_AND_FINISH;
						}

						if (CoolDot(ab, nDAB, da, mA) <= 0.f)			//outside AB side on DAB
						{
							if (CoolDot(ab, nABC, -ac, mA) <= 0.f)		//outside AB side on ABC, in voronoi region for AB
								goto REMOVE_C_AND_FINISH;//TODO

							//inside AB side on ABC
							goto REMOVE_D_AND_FINISH;
						}

						if (CoolDot(db, nDAB, ab, mD) <= 0.f)			//outside DB side on DAB
						{
							if (CoolDot(db, nDBC, -dc, mD) <= 0.f)		//outside DB side on DBC, in voronoi region for DB
								goto REMOVE_A_AND_FINISH;//TODO

							//inside DB side on DBC
							goto REMOVE_A_AND_FINISH;
						}

						//Remove C
						goto REMOVE_C_AND_FINISH;
					}

					//DA, AB, and DB can only be voronoi now

					if (Vector3::Dot(mD, nDCA) < 0.f)				//outside DCA
					{
						if (CoolDot(dc, nDCA, ac, mD) <= 0.f)		//outside DC side on DCA
						{
							if (CoolDot(dc, nDBC, -db, mD) <= 0.f)	//outside DC side on DBC, in voronoi region for DC
								goto REMOVE_A_AND_FINISH;//TODO

							//inside DC side on DBC
							goto REMOVE_A_AND_FINISH;
						}

						if (CoolDot(ac, nDCA, da, mA) <= 0.f)		//outside AC side on DCA, in voronoi region for DA
						{
							if (CoolDot(ac, nABC, -ab, mA) <= 0.f)	//outside AC side on ABC, in voronoi region for AC
								goto REMOVE_B_AND_FINISH;//TODO

							//inside AC side on ABC
							goto REMOVE_D_AND_FINISH;
						}

						if (CoolDot(da, nDCA, -dc, mD) <= 0.f)		//outside DA side on DCA, in voronoi region for DA
							goto REMOVE_B_AND_FINISH;//TODO

						goto REMOVE_B_AND_FINISH;
					}

					//DA, AB, DB, DC, and AC can only be voronoi now

					if (Vector3::Dot(mD, nDBC) < 0.f)				//outside DBC
					{
						if (CoolDot(db, nDBC, -dc, mD) <= 0.f)		//outside DB side on DBC, in voronoi region for DB
							goto REMOVE_A_AND_FINISH;//TODO
						
						if (CoolDot(bc, nDBC, db, mB) <= 0.f)		//outside BC side on DBC
						{
							if (CoolDot(bc, nABC, ab, mB) <= 0.f)	//outside BC side on ABC, in voronoi region for BC
								goto REMOVE_A_AND_FINISH;//TODO

							//inside BC side on ABC
							goto REMOVE_D_AND_FINISH;
						}

						if (CoolDot(dc, nDBC, -db, mD) <= 0.f)		//outside DC side on DBC, in voronoi region for DC
							goto REMOVE_A_AND_FINISH;//TODO

						goto REMOVE_A_AND_FINISH;
					}

					//all edges can only be voronoi now

					if (Vector3::Dot(mA, nABC) < 0.f)				//outside ABC
					{
						if (CoolDot(ab, nABC, -ac, mA) <= 0.f)		//outside AB side on ABC, in voronoi region for AB
							goto REMOVE_C_AND_FINISH;//TODO

						if (CoolDot(bc, nABC, ab, mB) <= 0.f)		//outside BC side on DBC, in voronoi region for BC
							goto REMOVE_A_AND_FINISH;//TODO

						if (CoolDot(ac, nABC, -ab, mA) <= 0.f)		//outside AC side on ABC, in voronoi region for AC
							goto REMOVE_B_AND_FINISH;//TODO

						goto REMOVE_D_AND_FINISH;
					}
				}

				//The origin is inside, overlapping
				return 0.f;

				REMOVE_A_AND_FINISH:
					closestPoint = ClosestPointToOriginOnTriangle(mD, mB, mC);
					dir = -closestPoint;

					MathematicaDebugState(mA, mB, mC, mD, closestPoint);

					a = b;
					b = c;
					c = d;
					i = 3;
					break;

				REMOVE_B_AND_FINISH:
					closestPoint = ClosestPointToOriginOnTriangle(mD, mA, mC);
					dir = -closestPoint;

					MathematicaDebugState(mA, mB, mC, mD, closestPoint);

					b = c;
					c = d;
					i = 3;
					break;

				REMOVE_C_AND_FINISH:
					closestPoint = ClosestPointToOriginOnTriangle(mD, mA, mB);
					dir = -closestPoint;

					MathematicaDebugState(mA, mB, mC, mD, closestPoint);

					c = d;
					i = 3;
					break;

				REMOVE_D_AND_FINISH:
					closestPoint = ClosestPointToOriginOnTriangle(mA, mB, mC);
					dir = -closestPoint;

					MathematicaDebugState(mA, mB, mC, mD, closestPoint);

					i = 3;
					break;
			}
